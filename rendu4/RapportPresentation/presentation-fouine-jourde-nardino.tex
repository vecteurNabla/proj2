\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}

\usepackage{verbatim}
\usepackage{minted}

\usepackage{tikz}

\newcommand{\tocpage}{
  \begin{frame}
    \tableofcontents[currentsection]
  \end{frame}
}

\def\labelenumi{\theenumi}
\usepackage{enumitem}

\setitemize[1]{label=$\circ$}

\setenumerate[1]{label=\arabic*.}

% \usetheme{Luebeck}
\usetheme{CambridgeUS}

% \usecolortheme{dolphin}
\usecolortheme{seahorse}

\setbeamertemplate{section in toc}{%
  ({\inserttocsectionnumber})~{\inserttocsection}%
}

\setbeamertemplate{navigation symbols}{}



\title{Présentation projet Fouine}
\author{Robin Jourde \& Nicolas Nardino}
\date{mai 2021}

\begin{document}


\begin{frame}
  \titlepage
\end{frame}


\begin{frame}{Dites \og Bonjour \fg~à notre amie la fouine !}
  \begin{center}
    \tiny
    \verbatiminput{fouine-ascii.txt}
  \end{center}
\end{frame}


\begin{frame}{Table de matières}
  \tableofcontents
\end{frame}


\section{Fouine, qu'est-ce que c'est ?}

\tocpage

\begin{frame}{Un terme polysémique}
  \begin{itemize}
  \item<2-> un petit animal trop mignon : \\
    \includegraphics[width=0.2\linewidth]{figures/photo_fouine.jpg}
  \item<3-> un sous langage de OCaml
  \item<4-> un interpréteur de ce sous langage
  \end{itemize}

  \visible<5-> {Par la suite on n'utilisera le terme que dans ses 2 derniers sens.}
\end{frame}

\begin{frame}{Le langage}
  Grammaire simplifiée :
  \begin{align*}
    e~:=&~let~(rec)~p~=~e_1~in~e_2~|~fun~p~\to~e_1~|~e_1~e_2~|~e_1~:=~e_2 \\
        &|~!e_1~|~if~e_1~then~e_2~else~e_3~|~match~e_1~with~[|~p_i~->~e_i] \\
        &|~e_1~::~e_2~|~try~e_1~with~E~p~->~e_2~|~raise~e_1~|~p
  \end{align*}

  $p$ représente un pattern :
  $$
  p~:=~x~|~\_~|~k~|~p_1,~p_2~|~p_1~::~p_2
  $$

  $k$ est une constante

  \visible <2-> {Et les opérations arithmétiques me diriez vous ? ... }

  \visible <3-> {... Et là vous croyiez que j'allais le dire maintenant mais en fait non, il a falloir attendre ! Suspens ...!!  }
\end{frame}


\begin{frame}{L'interprète}
  \begin{itemize}

  \item<1-> \texttt{./fouine [options] test1515.ml}

  \item<2->  Mais quelles options ??? Demandons à fouine : \texttt{./fouine --help}

  \item<3->  \texttt{
      -showsrc -debug -tree -outval -stdin -cps -outcode -outcode-tree -run -autotest -optim -reduc -prefix -notypes -showtypes -showmoretypes -monotypes -cpstypes
    }

  \end{itemize}
\end{frame}


\begin{frame}[fragile]{Un exemple}
  \begin{itemize}
  \item fichier de test \texttt{not.ml}

    \mint{ocaml}|let x = not (0>1) in if x then prInt 1 else prInt 0|

  \item
    \begin{minted}[breaklines]{shell}
./fouine -debug -outval -showtypes not.ml
x : bool
- : int
let x = not (( > ) (0) (1)) in (if x then prInt (1) else prInt (0))
1
1
    \end{minted}


  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \fontsize{7}{7} \selectfont
  \begin{minted}[breaklines]{ocaml}
./fouine -cps -outcode not.ml
let main_transform = (fun (x4V13r_L3r0yk1,x4V13r_L3r0ykE1) -> (fun (x4V13r_L3r0yk10,x4V13r_L3r0ykE10) -> (fun (x4V13r_L3r0yk12,x4V13r_L3r0ykE12) -> (fun (x4V13r_L3r0yk16,x4V13r_L3r0ykE16) -> x4V13r_L3r0yk16 (1)) (((fun x4V13r_L3r0yfst12 -> (fun (x4V13r_L3r0yk13,x4V13r_L3r0ykE13) -> (fun (x4V13r_L3r0yk15,x4V13r_L3r0ykE15) -> x4V13r_L3r0yk15 (0)) (((fun x4V13r_L3r0yfst13 -> (fun (x4V13r_L3r0yk14,x4V13r_L3r0ykE14) -> x4V13r_L3r0yk14 ((fun x4V13r_L3r0yv14 -> (fun (x4V13r_L3r0yk14,x4V13r_L3r0ykE14) -> x4V13r_L3r0yk14 ((fun x4V13r_L3r0yw14 -> (fun (x4V13r_L3r0yk14,x4V13r_L3r0ykE14) -> x4V13r_L3r0yk14 (( > ) (x4V13r_L3r0yv14) (x4V13r_L3r0yw14))))))))) (((fun x4V13r_L3r0ysnd13 -> x4V13r_L3r0ysnd13 (x4V13r_L3r0yfst13) ((x4V13r_L3r0yk13,x4V13r_L3r0ykE13))),x4V13r_L3r0ykE13))),x4V13r_L3r0ykE13))) (((fun x4V13r_L3r0ysnd12 -> x4V13r_L3r0ysnd12 (x4V13r_L3r0yfst12) ((x4V13r_L3r0yk12,x4V13r_L3r0ykE12))),x4V13r_L3r0ykE12))),x4V13r_L3r0ykE12))) (((fun x4V13r_L3r0yfst10 -> (fun (x4V13r_L3r0yk11,x4V13r_L3r0ykE11) -> x4V13r_L3r0yk11 ((fun x4V13r_L3r0yv11 -> (fun (x4V13r_L3r0yk11,x4V13r_L3r0ykE11) -> x4V13r_L3r0yk11 (not (x4V13r_L3r0yv11)))))) (((fun x4V13r_L3r0ysnd10 -> x4V13r_L3r0ysnd10 (x4V13r_L3r0yfst10) ((x4V13r_L3r0yk10,x4V13r_L3r0ykE10))),x4V13r_L3r0ykE10))),x4V13r_L3r0ykE10))) (((fun x -> (fun (x4V13r_L3r0yk2,x4V13r_L3r0ykE2) -> (fun (x4V13r_L3r0yk9,x4V13r_L3r0ykE9) -> x4V13r_L3r0yk9 (x)) (((fun x4V13r_L3r0yb2 -> (if x4V13r_L3r0yb2 then (fun (x4V13r_L3r0yk6,x4V13r_L3r0ykE6) -> (fun (x4V13r_L3r0yk8,x4V13r_L3r0ykE8) -> x4V13r_L3r0yk8 (1)) (((fun x4V13r_L3r0yfst6 -> (fun (x4V13r_L3r0yk7,x4V13r_L3r0ykE7) -> x4V13r_L3r0yk7 ((fun x4V13r_L3r0yv7 -> (fun (x4V13r_L3r0yk7,x4V13r_L3r0ykE7) -> x4V13r_L3r0yk7 (prInt (x4V13r_L3r0yv7)))))) (((fun x4V13r_L3r0ysnd6 -> x4V13r_L3r0ysnd6 (x4V13r_L3r0yfst6) ((x4V13r_L3r0yk6,x4V13r_L3r0ykE6))),x4V13r_L3r0ykE6))),x4V13r_L3r0ykE6))) else (fun (x4V13r_L3r0yk3,x4V13r_L3r0ykE3) -> (fun (x4V13r_L3r0yk5,x4V13r_L3r0ykE5) -> x4V13r_L3r0yk5 (0)) (((fun x4V13r_L3r0yfst3 -> (fun (x4V13r_L3r0yk4,x4V13r_L3r0ykE4) -> x4V13r_L3r0yk4 ((fun x4V13r_L3r0yv4 -> (fun (x4V13r_L3r0yk4,x4V13r_L3r0ykE4) -> x4V13r_L3r0yk4 (prInt (x4V13r_L3r0yv4)))))) (((fun x4V13r_L3r0ysnd3 -> x4V13r_L3r0ysnd3 (x4V13r_L3r0yfst3) ((x4V13r_L3r0yk3,x4V13r_L3r0ykE3))),x4V13r_L3r0ykE3))),x4V13r_L3r0ykE3)))) ((x4V13r_L3r0yk2,x4V13r_L3r0ykE2))),x4V13r_L3r0ykE2))) ((x4V13r_L3r0yk1,x4V13r_L3r0ykE1))),x4V13r_L3r0ykE1))) in main_transform (((fun x4V13r_L3r0yx -> x4V13r_L3r0yx),(fun x4V13r_L3r0yx -> x4V13r_L3r0yx))
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}[breaklines]{ocaml}
./fouine -cps -outcode -optim -prefix "" not.ml 
let main_transform = (fun (k1,kE1) -> (fun fst10 -> (fun x -> (if x then (fun (k6,kE6) -> k6 (prInt (1))) else (fun (k3,kE3) -> k3 (prInt (0)))) ((k1,kE1))) (not (fst10))) (( > ) (0) (1))) in main_transform (((fun x -> x),(fun x -> x)))
  \end{minted}
  
\end{frame}

\section{Fouine, comment ça marche ?}

\tocpage

\begin{frame}{Que fait fouine ?}
  Étapes :
  \begin{enumerate}
  \item Lire : lexer et parser
  \item Typer
  \item (Si souhaité) traduction CPS
  \item (Si souhaité) réduction
  \item Évaluer
  \end{enumerate}

  Pour tout cela on a besoin de représenter les expressions...
\end{frame}

\begin{frame}{Des constructeurs et des types}
  \include{graphe}
\end{frame}



\begin{frame}{La bibliothèque standard}
  On tient notre promesse !

  \begin{itemize}
  \item \texttt{fst , snd}
  \item \texttt{prInt}
  \item \texttt{ref}
  \item \texttt{( + ) , ( - ) , ( * ) , ( / )}
  \item \texttt{( \&\& ) ,  ( || )}
  \item \texttt{not}
  \item \texttt{( <= ) , ( >= ) , ( < ) , ( > )}
  \item \texttt{( = ) , ( <> )}
  \end{itemize}
\end{frame}

\begin{frame}{Exemple détaillé : \texttt{prInt}}
  \begin{itemize}
  \item code de la fonction

    \texttt{ let \_prInt m = function }

    \texttt{ | Const (Int i) -> (print\_int i ; print\_newline () ; \~\& (Int i) ) }

    \texttt{ | \_ -> raise PrInt\_not\_int }

  \item insertion dans l'environnement

    \mint{ocaml}|("prInt", StdLib _prInt) :: ...|

  \item type

    \mint{ocaml}|("prInt", TFun(TInt, TInt) ):: ... |


  \end{itemize}
\end{frame}

\section{Conclusion}
\begin{frame}{C'est fini !}
  \begin{center}
    \Huge Merci à tous \& Bisous !
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \fontsize{2}{2} \selectfont
    \verbatiminput{daniel-ascii.tex}
  \end{center}
\end{frame}

\end{document}



